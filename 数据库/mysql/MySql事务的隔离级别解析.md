## MySql事务的隔离级别解析

##### 一、日志

1. binlog（逻辑日志）

   它是MySql服务层的日志

   - statement 格式的话是记**sql语句**
   - row格式会记录**行的内容**，记两条，更新前和更新后都有。

   作用：

   备份和恢复数据（可以指定恢复到某一时刻哦）

2. redo log（物理日志）

   这是innodb引擎提供的日志。为什么说它是物理日志呢，因为它对应着磁盘里的数据修改信息，我们的修改sql成功后实际上是对redo log进行了写入，然后某个线程再根据redo log刷新到磁盘中。

   - 每一行记录一个修改

   - 检查点。检查点前面的行全部被写入到磁盘里了，把还没写入磁盘的行排成一个队列的话，检查点就是队列头指针。 

     我们比较一下上面两种日志，比如执行`update T set c=c+1 where ID=2;`操作，如下图：

![](E:\读书笔记\readingNotes\mysql\img\a.png)

需要注意的是上面写入redolog、binlog做到了一致性，就是先让写入的信息处于prepare阶段，即**两阶段提交**。

3. undo log（回滚日志）

用来回滚的，并且在innodb中用来实现MVCC，日志中记录的是行数据

- 其实数据库里的每一行数据还有几个**隐藏字段**，比如更新了这行的事务id、一个指向undo log行的指针，标记当前是否被删除等。就是利用这个实现了多版本（不同事务）数据共存。

- 每一行记录就记录着修改行的信息？链表结构？

##### 二、事务的隔离级别

> 事务的四大特性之一隔离性，就是在执行过程中一个事务对另一个事务不可见

1. 读未提交
   - 会发生脏读，一个事务读到另一个事务未提交的数据
   - 啥都没有，直接读取内存中最新的数据

2. 读已提交
   - 会发生不可重复读，一个事务前后读到的数据不一致
   - **没有设置读锁**，写锁是针对事务的，也就是事务结束锁才会释放
   - 实现：MVCC，只会读取最新版本且已提交的数据

3. 可重复读
   - 还是没有设置读锁，有个间隙锁，也就是可以锁掉连续多少行数据，不能在里面插入数据，避免了一下幻读
   - 实现：MVCC，只会读取第一个早于或等于当前事务id的数据行（对于有删除标记的行，如果其事务id大于我，那么我将这行当作没有被删除）
   - 还是会发生一些幻读（前后读到的数据**行数**不一致了）

4. 可串行化
   - 实现：在事务层面，读写互斥
   - 基本防止了一切问题